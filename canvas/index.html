<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Visualizator</title>
    <link rel="icon" href="\assets\favicon.ico" type="image/x-icon" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          Cantarell, sans-serif;
        overflow: hidden;
        background: #1e1e1e;
        color: #dcddde;
      }

      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: relative;
        cursor: grab;
        overflow: hidden;
      }

      #canvas-container.grabbing {
        cursor: grabbing;
      }

      #canvas {
        position: absolute;
        transform-origin: 0 0;
      }

      .node {
        position: absolute;
        background: #2d2d2d;
        border: 1px solid #404040;
        border-radius: 4px;
        padding: 12px;
        font-size: 14px;
        line-height: 1.5;
        white-space: pre-wrap;
        overflow: auto;
        transition: box-shadow 0.2s;
      }

      .node:hover {
        box-shadow: 0 0 10px rgba(100, 100, 255, 0.3);
        z-index: 100;
      }

      .node.group {
        background: rgba(80, 80, 120, 0.15);
        border: 2px solid #505078;
        border-radius: 1px;
        z-index: 0;
      }

      .node.group .group-label {
        position: absolute;
        top: 0;
        left: 5px;
        font-weight: bold;
        font-size: 16px;
        color: #a0a0ff;
      }

      .node h1 {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 8px;
      }

      .node h2 {
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 6px;
      }

      .node h3 {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 6px;
        color: #8ab4f8;
      }

      .node h4 {
        font-size: 16px;
        font-weight: bold;
        margin-bottom: 4px;
      }

      .node h5 {
        font-size: 15px;
        font-weight: bold;
        margin-bottom: 4px;
        color: #ffa07a;
      }

      .node h6 {
        font-size: 14px;
        font-weight: bold;
        margin-bottom: 4px;
      }

      .node a {
        color: #8ab4f8;
        text-decoration: none;
      }

      .node a:hover {
        text-decoration: underline;
      }

      .node em {
        font-style: italic;
        color: #d4a5d4;
      }

      .node strong {
        font-weight: bold;
        color: #ffd700;
      }

      .text-center {
        text-align: center;
      }

      svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 10000px;
        height: 10000px;
        pointer-events: none;
        z-index: 50;
        overflow: visible;
      }

      .edge {
        stroke: #8080ff;
        stroke-width: 2;
        fill: none;
      }

      .edge-arrow {
        fill: #8080ff;
      }

      
    </style>
  </head>
  <body>
    <div id="canvas-container">
      <div id="canvas">
        <svg id="edges"></svg>
        <div id="nodes"></div>
      </div>
    </div>

    

    <script>
      // Datos del canvas embebidos
      let canvasData;

      // Variables de estado
      let scale = 1;
      let translateX = 0;
      let translateY = 0;
      let isDragging = false;
      let startX = 0;
      let startY = 0;

      // Cargar el archivo .canvas dinámicamente
      async function loadCanvasData() {
        try {
          const canvasFiles = ["D_Primer Paper.canvas"];

          for (const filename of canvasFiles) {
            try {
              const response = await fetch(`../canvas/${filename}`);
              if (response.ok) {
                canvasData = await response.json();
                renderCanvas();
                resetView();
                return;
              }
            } catch (e) {
              console.log(`Could not load ${filename}:`, e);
            }
          }

          console.error("Could not load any canvas file");
        } catch (error) {
          console.error("Error loading canvas data:", error);
        }
      }

      // Función para parsear markdown básico
      function parseMarkdown(text) {
        let html = text;

        // Links [text](url)
        html = html.replace(
          /\[([^\]]+)\]\(([^)]+)\)/g,
          '<a href="$2" target="_blank">$1</a>',
        );

        // Headers
        html = html.replace(/^###### (.*$)/gim, "<h6>$1</h6>");
        html = html.replace(/^##### (.*$)/gim, "<h5>$1</h5>");
        html = html.replace(/^#### (.*$)/gim, "<h4>$1</h4>");
        html = html.replace(/^### (.*$)/gim, "<h3>$1</h3>");
        html = html.replace(/^## (.*$)/gim, "<h2>$1</h2>");
        html = html.replace(/^# (.*$)/gim, "<h1>$1</h1>");

        // Bold
        html = html.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");

        // Italic
        html = html.replace(/\*(.*?)\*/g, "<em>$1</em>");

        // Line breaks
        html = html.replace(/\n/g, "<br>");

        return html;
      }

      // Función para obtener el punto de conexión de un nodo
      function getConnectionPoint(node, side) {
        const x = node.x;
        const y = node.y;
        const w = node.width;
        const h = node.height;

        switch (side) {
          case "top":
            return { x: x + w / 2, y: y };
          case "bottom":
            return { x: x + w / 2, y: y + h };
          case "left":
            return { x: x, y: y + h / 2 };
          case "right":
            return { x: x + w, y: y + h / 2 };
          default:
            return { x: x + w / 2, y: y + h / 2 };
        }
      }

      // Función para dibujar una línea (edge)
      function drawEdge(edge) {
        const fromNode = canvasData.nodes.find((n) => n.id === edge.fromNode);
        const toNode = canvasData.nodes.find((n) => n.id === edge.toNode);

        if (!fromNode || !toNode) return "";

        const from = getConnectionPoint(fromNode, edge.fromSide);
        const to = getConnectionPoint(toNode, edge.toSide);

        const pathMethod = edge.styleAttributes?.pathfindingMethod || "direct";

        let pathData;
        if (pathMethod === "square") {
          // Ruta con ángulos rectos
          const midX = (from.x + to.x) / 2;
          const midY = (from.y + to.y) / 2;

          // primera parte del path en funcion de la dirección de salida del nodo origen
          if (edge.fromSide === "left" || edge.fromSide === "right") {
            pathData = `M ${from.x} ${from.y} L ${midX} ${from.y}`;
          } else {
            pathData = `M ${from.x} ${from.y} L ${from.x} ${midY}`;
          }

          // segunda parte del path en funcion de la dirección de entrada del nodo destino
          if (edge.toSide === "left" || edge.toSide === "right") {
            pathData += ` L ${midX} ${to.y} L ${to.x} ${to.y}`;
          } else {
            pathData += ` L ${to.x} ${midY} L ${to.x} ${to.y}`;
          }
        } else {
          // Línea directa con curva de Bézier cúbica
          const curvefactor = 0.55;

          // detectar entrada en nodo destino para restar tamaño de flecha
          let toXmod = 0;
          let toYmod = 0;
          if (edge.toSide === "left") {
            toXmod = -20;
          } else if (edge.toSide === "right") {
            toXmod = 20;
          } else if (edge.toSide === "top") {
            toYmod = -20;
          } else if (edge.toSide === "bottom") {
            toYmod = 20;
          }

          // Puntos de control basados en la dirección de salida/entrada
          let ctrl1X = from.x;
          let ctrl1Y = from.y;
          let ctrl2X = to.x+toXmod;
          let ctrl2Y = to.y+toYmod;

          // Primer punto de control (salida del nodo origen)
          if (edge.fromSide === "left" || edge.fromSide === "right") {
            ctrl1X = from.x + (to.x + toXmod - from.x) * curvefactor;
            ctrl1Y = from.y;
          } else {
            ctrl1X = from.x;
            ctrl1Y = from.y + (to.y + toYmod - from.y) * curvefactor;
          }

          // Segundo punto de control (entrada al nodo destino)
          if (edge.toSide === "left" || edge.toSide === "right") {
            ctrl2X = to.x + toXmod - (to.x + toXmod - from.x) * 0.25;
            ctrl2Y = to.y + toYmod;
          } else {
            ctrl2X = to.x + toXmod;
            ctrl2Y = to.y + toYmod - (to.y + toYmod - from.y) * 0.25;
          }

          pathData = `M ${from.x} ${from.y} C ${ctrl1X} ${ctrl1Y}, ${ctrl2X} ${ctrl2Y}, ${to.x + toXmod} ${to.y + toYmod} L ${to.x} ${to.y}`;
        }

        return `<path class="edge" d="${pathData}" marker-end="url(#arrowhead)" />`;
      }

      // Función para renderizar el canvas
      function renderCanvas() {
        if (!canvasData) return;

        const nodesContainer = document.getElementById("nodes");
        const edgesContainer = document.getElementById("edges");

        // Limpiar contenedores
        nodesContainer.innerHTML = "";

        // Renderizar grupos primero (para que estén debajo)
        canvasData.nodes
          .filter((node) => node.type === "group")
          .forEach((node) => {
            const nodeEl = document.createElement("div");
            nodeEl.className = "node group";
            nodeEl.style.left = node.x + "px";
            nodeEl.style.top = node.y + "px";
            nodeEl.style.width = node.width + "px";
            nodeEl.style.height = node.height + "px";

            if (node.label && node.label.trim()) {
              const label = document.createElement("div");
              label.className = "group-label";
              label.textContent = node.label;
              nodeEl.appendChild(label);
            }

            nodesContainer.appendChild(nodeEl);
          });

        // Renderizar nodos de texto
        canvasData.nodes
          .filter((node) => node.type === "text")
          .forEach((node) => {
            const nodeEl = document.createElement("div");
            nodeEl.className = "node";
            nodeEl.style.left = node.x + "px";
            nodeEl.style.top = node.y + "px";
            nodeEl.style.width = node.width + "px";
            nodeEl.style.height = node.height + "px";

            // Aplicar estilos adicionales
            if (node.styleAttributes?.textAlign) {
              nodeEl.classList.add("text-" + node.styleAttributes.textAlign);
            }

            // Parsear markdown y agregar contenido
            nodeEl.innerHTML = parseMarkdown(node.text);

            nodesContainer.appendChild(nodeEl);
          });

        // Agregar definición de marcador de flecha
        let edgesHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" class="edge-arrow" />
                    </marker>
                </defs>
            `;

        // Renderizar edges
        canvasData.edges.forEach((edge) => {
          edgesHTML += drawEdge(edge);
        });
        edgesContainer.innerHTML = edgesHTML;
      }

      // Funciones de zoom y navegación
      function updateTransform() {
        const canvas = document.getElementById("canvas");
        canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
        document.getElementById("zoom-info").textContent =
          `Zoom: ${Math.round(scale * 100)}%`;
      }

      function zoomIn() {
        const container = document.getElementById("canvas-container");
        const rect = container.getBoundingClientRect();
        const mouseX = rect.width / 2;
        const mouseY = rect.height / 2;
        applyZoom(1.2, mouseX, mouseY);
      }

      function zoomOut() {
        const container = document.getElementById("canvas-container");
        const rect = container.getBoundingClientRect();
        const mouseX = rect.width / 2;
        const mouseY = rect.height / 2;
        applyZoom(0.833, mouseX, mouseY);
      }

      function applyZoom(factor, mouseX, mouseY) {
        const newScale = Math.max(0.1, Math.min(3, scale * factor));
        
        // Aplicar el zoom hacia el ratón
        const canvasX = (mouseX - translateX) / scale;
        const canvasY = (mouseY - translateY) / scale;
        translateX = mouseX - canvasX * newScale;
        translateY = mouseY - canvasY * newScale;
        
        scale = newScale;
        updateTransform();
      }

      function resetView() {
        scale = 0.4;
        translateX = window.innerWidth / 2;
        translateY = window.innerHeight / 2;
        updateTransform();
      }

      // Interactividad
      const container = document.getElementById("canvas-container");

      function handlePointerDown(clientX, clientY) {
        isDragging = true;
        startX = clientX - translateX;
        startY = clientY - translateY;
        container.classList.add("grabbing");
      }

      function handlePointerMove(clientX, clientY) {
        if (isDragging) {
          translateX = clientX - startX;
          translateY = clientY - startY;
          updateTransform();
        }
      }

      function handlePointerUp() {
        isDragging = false;
        container.classList.remove("grabbing");
      }

      function handleWheel(event) {
        event.preventDefault();
        const rect = container.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const delta = event.deltaY > 0 ? 0.9 : 1.1;
        applyZoom(delta, mouseX, mouseY);
      }

      // Event Listeners
      // móvil
      container.addEventListener("touchstart", (e) => {
        const touch = e.touches[0];
        handlePointerDown(touch.clientX, touch.clientY);
      });
      container.addEventListener("touchmove", (e) => {
        const touch = e.touches[0];
        handlePointerMove(touch.clientX, touch.clientY);
      });
      container.addEventListener("touchend", handlePointerUp);

      // pc
      container.addEventListener("mousedown", (e) => {handlePointerDown(e.clientX, e.clientY);});
      container.addEventListener("mousemove", (e) => { handlePointerMove(e.clientX, e.clientY);});
      container.addEventListener("mouseup", handlePointerUp);
      container.addEventListener("mouseleave", handlePointerUp);
      container.addEventListener("wheel", handleWheel);

      // Inicializar
      loadCanvasData();
    </script>
  </body>
</html>