<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .node { cursor: grab; fill: #e9f5ff; }
        .link {   
                  stroke-linecap: square; /* Extremos cuadrados */
                  /*shape-rendering: crispEdges; /* Líneas sin suavizado */ }
        svg { background: #050010;
            width: 98vw; 
            height: 98vh; 
            margin: 5px auto; 
            border-style:solid;
            border-color: white;
            border-width: 2px;
            display: block; 
        }
        
        .node-id {
              
              pointer-events: none;
              font-family: "Consolas", monospace;
              font-size: 15px;
              fill: #ffffff;
            }

        @media (max-width: 768px) {
        .node-id { font-size: 13px; }
        }

        #mindmap {
            background: #402c6c
            
        }

        .hidden {
            display: none;
        }

    

        body {
            margin: 0;
            overflow: hidden; /* Oculta el scroll no deseado */
            background: #000000;
        }
    </style>
    
</head>
<body>

    <div id="mindmap">

        <svg></svg>
    </div>
    

    <script>

    //Variables    
    const isMobile = window.matchMedia("(max-width: 768px)").matches;
    const NODE_R_BASE = 4; // Tamaño base
    const NODE_R_ZOOM = 10; // Tamaño al hacer hover
    const NODE_R_BASE_MOBILE = 6;
    const NODE_R_ZOOM_MOBILE = 8;
    const NODE_R_BOUND = 25;
    let svg, simulation,width, height;

    fetch('projects.json') //contiene un array con todos los proyectos
    .then(response => response.json())
    .then(data => {
    const nodes = data.nodes;
    const links = generateLinks(nodes);
    const tagColors = {
      "arq": "#FF6B6B",  // Rojo pastel
      "inm": "#4ECDC4",  // Turquesa
      "ins": "#45B7D1",  // Azul claro
      "inv": "#96CEB4",  // Verde menta
      "par": "#FFCCAD",  // Amarillo claro
      "doc": "#D4A5A5"   // Rosa polvoriento
    };


    //funciones config de simulación

    function initSVG() {
        //inicializa el svg y aplica una primera fuerza al centro
        width = window.innerWidth;
        height = window.innerHeight;
        svg.attr("width", width).attr("height", height);
        if(simulation){simulation.force("center", d3.forceCenter(width / 2, height / 2));}
    }
    
    function restartSimulation() {
        //reinicia la simulación (en eventos de resize)
        simulation.alpha(0.5).restart();
    }
    
    function fixBounds() {
              
              

              const graphNodes = simulation.nodes(); 

              graphNodes.forEach((node) => {
                  // Limitar posición X
                  if (node.x - NODE_R_BOUND < 0) {
                      node.x = NODE_R_BOUND;
                      node.vx = 0;
                  }
                  if (node.x + NODE_R_BOUND > width) {
                      node.x = width - NODE_R_BOUND;
                      node.vx = 0;
                  }
                
                  // Limitar posición Y
                  if (node.y - NODE_R_BOUND < 0) {
                      node.y = NODE_R_BOUND;
                      node.vy = 0; 
                  }
                  if (node.y + NODE_R_BOUND > height) {
                      node.y = height - NODE_R_BOUND;
                      node.vy = 0; 
                  }
             });
            }
    
    //funciones para links
    
    function generateLinks(nodes) {
        // Función mágica para generar links
        const links = [];
        
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const nodeA = nodes[i];
                const nodeB = nodes[j];
                const sharedTags = nodeA.tags.filter(tag => nodeB.tags.includes(tag));
                
                sharedTags.forEach((tag, index) => {
                    let curvature;
                    if (index === 0) {
                        curvature = 1000; 
                    } else {
                        
                        const adjustedIndex = index - 1; // Restamos 1 para empezar desde 0
                        //curvature = (adjustedIndex % 2 === 0 ? 1 : -1) * (Math.floor(adjustedIndex / 2) + 1) * 5;
                        curvature =  (Math.ceil(adjustedIndex / 2)) * 3;
                    }
                    links.push({
                        source: nodeA.id,
                        target: nodeB.id,
                        weight: sharedTags.length/2, // Número de tags compartidos
                        tag: tag,
                        curvature: curvature,
                        order: index % 2
                    });
                });
            }
        }
        return links;
    }
    
    function arcPath(d) {
        const start = d.order === 0 ? { x: d.source.x, y: d.source.y } : { x: d.target.x, y: d.target.y };
        const end = d.order === 0 ? { x: d.target.x, y: d.target.y } : { x: d.source.x, y: d.source.y };
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const dr = Math.sqrt(dx * dx + dy * dy) * d.curvature; // Radio del arco

        return `
              M${start.x},${start.y}
              A${dr},${dr} 0 0,1 ${end.x},${end.y}
              `;
    }

    //funciones para interactividad

    function handleNodeHover(event, d) {
        // Función para manejar el "hover" (mouseover/touchstart)
    labels.filter(labelD => labelD === d)
        .text(`[${d.name}]`);
    d3.select(event.currentTarget)
        .transition()
        .duration(50)
        .attr("r", isMobile ? NODE_R_ZOOM_MOBILE : NODE_R_ZOOM); // Tamaño móvil/desktop
    link.transition()
        .duration(800)
        .attr("stroke-opacity", l => 
            (l.source.id === d.id || l.target.id === d.id) ? 0.9 : 0.1
        );
    }

    function handleNodeUnhover(event, d) {
        // Función para manejar el "unhover" (mouseout/touchend)
        labels.filter(labelD => labelD === d)
            .text(`[${d.id}]`);
        d3.select(event.currentTarget)
            .transition()
            .duration(450)
            .attr("r", isMobile ? NODE_R_BASE_MOBILE : NODE_R_BASE); // Tamaño móvil/desktop
        link.transition()
            .duration(800)
            .attr("stroke-opacity", 0.1);
    }


    function drag(simulation) {
        return d3.drag()
        .on("start", function(event, d) {
            event.sourceEvent.preventDefault(); //esto evita scroll en moviles, quiza haya que quitarlo
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;

            

        })
        .on("drag", (event, d) => {
            d.fx = event.x;
            d.fy = event.y;
            link.attr("d", arcPath);
        })
        .on("end", (event, d) => {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;


        });
        }


        // Inicializar SVG
        svg = d3.select("svg");
        initSVG();

        // Crear simulación
        simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).strength(d => d.weight * 0.04))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2).strength(0.02));

        // Dibujar enlaces
        const link = svg.append("g")
            .selectAll("path")
            .data(links)
            .join("path")
            .attr("class", "link")
            .attr("stroke-width", 1)
            .attr("stroke-opacity",0.2)
            .attr("fill", "none")
            .attr("stroke", d => tagColors[d.tag]);



        // Crear etiquetas
        const labels = svg.append("g")
            .selectAll("text")
            .data(nodes)
            .join("text")
            .attr("class", "node-id")
            .text(d =>`[${d.id}]`) // Mostrar el ID
            .attr("text-anchor", "left")
            .attr("dy", "-0.5em")
            .attr("dx","0.5em")
              
              
        // Dibujar nodos
        const node = svg.append("g")
            .selectAll("circle")
            .data(nodes)
            .join("circle")
            .attr("class", "node")
            .attr("r", isMobile ? NODE_R_BASE_MOBILE : NODE_R_BASE)
            .call(drag(simulation))
            .on("mouseover touchstart", handleNodeHover)
            .on("mouseout touchend", handleNodeUnhover); 

        

            

        // Actualizar posiciones
        simulation.on("tick", () => {
          fixBounds();
          link.attr("d", arcPath); 

          node.attr("cx", d => d.x)
              .attr("cy", d => d.y);

          labels
              .attr("x", d => d.x)
              .attr("y", d => d.y);

          

        });



        initSVG();
        window.addEventListener("resize", () => {
                    initSVG();
                    restartSimulation();
        });
        svg.on("touchstart", (event) => {
        if (event.target.tagName === "svg") {
            link.transition().attr("stroke-opacity", 0.1);
        }
    });

        
      })
    </script>
</body>
</html>